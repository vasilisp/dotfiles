;; Fail fast: Emacs 30+
(when (< emacs-major-version 30)
  (error "This init requires Emacs 30+ (you have %s)" emacs-version))

;;;; Backups / autosave

(let ((dir (expand-file-name "~/.emacs-backup/")))
  (make-directory dir t)
  (setq backup-directory-alist `(("." . ,dir))))

(setq auto-save-default nil)

;;;; Generic settings

(column-number-mode 1)
(setq-default indent-tabs-mode nil)
(put 'downcase-region 'disabled nil)

;;;; Package management (builtin `package`, MELPA)

(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)

;;;; Text-mode: auto-fill

(add-hook 'text-mode-hook #'auto-fill-mode)

;;;; Mail buffers (mutt / temp messages)

(add-to-list 'auto-mode-alist '("/mutt-"   . mail-mode))
(add-to-list 'auto-mode-alist '("/tmpmsg-" . mail-mode))

;;;; C: Linux-ish formatting

(add-hook 'c-mode-common-hook
          (lambda ()
            (local-set-key (kbd "RET") #'newline-and-indent)))

(defun linux-c-mode ()
  "C mode with adjusted defaults for use with the Linux kernel."
  (interactive)
  (c-mode)
  (c-set-style "K&R")
  (setq-local tab-width 8)
  (setq-local indent-tabs-mode t)
  (setq-local c-basic-offset 8))

(add-to-list 'auto-mode-alist '("\\.[ch]\\'" . linux-c-mode))

;;;; Markdown (optional)

(use-package markdown-mode
    :ensure t
    :mode ("\\.md\\'" "\\.markdown\\'"))

;;;; OCaml tooling (optional, degrades gracefully)

(use-package tuareg
    :ensure t
    :mode ("\\.mli?\\'")
    :custom
    (tuareg-in-indent 0)
    :hook
    (tuareg-mode . (lambda ()
                     (add-hook 'before-save-hook
                               #'delete-trailing-whitespace
                               nil t))))

(when (and (executable-find "opam")
           (not (getenv "OPAM_SWITCH_PREFIX")))
  (ignore-errors
    (dolist (var
              (car
               (read-from-string
                (shell-command-to-string "opam config env --sexp"))))
      (setenv (car var) (cadr var)))))

(let ((op (getenv "OPAM_SWITCH_PREFIX")))
  (when (and op (file-directory-p op))
    (add-to-list 'load-path (expand-file-name "share/emacs/site-lisp" op))
    (add-to-list 'exec-path (expand-file-name "bin" op))))

(when (locate-library "ocp-indent")
  (autoload 'ocp-setup-indent "ocp-indent" "Indent OCaml using ocp-indent." t)
  (add-hook 'tuareg-mode-hook #'ocp-setup-indent))

(when (locate-library "merlin")
  (autoload 'merlin-mode "merlin" "Merlin mode." t)
  (add-hook 'tuareg-mode-hook #'merlin-mode))

(when (locate-library "utop")
  (autoload 'utop "utop" "Toplevel for OCaml." t))

(when (locate-library "camldebug")
  (autoload 'camldebug "camldebug" "Run the Caml debugger." t))

;;;; Server

(require 'server)
(setq server-name "std")
(unless (server-running-p)
  (server-start))

(defun shutdown ()
  "Save buffers and quit Emacs."
  (interactive)
  (save-some-buffers)
  (kill-emacs))

;;;; Compilation keybindings

(global-set-key (kbd "C-c c") #'compile)
(global-set-key (kbd "C-c r") #'recompile)

;;;; F10 now used for the buffer menu

(with-eval-after-load 'menu-bar
  (global-set-key (kbd "<f9>") #'menu-bar-open)
  (global-set-key (kbd "<f10>") #'buffer-menu-open))

;;;; auto-revert for nicer AI agent interaction

(global-auto-revert-mode 1)
(setq global-auto-revert-non-file-buffers t)
(setq auto-revert-verbose nil)

;;;; Go (optional)

(add-hook 'go-mode-hook
          (lambda ()
            ;; lsp-mode is optional
            (when (fboundp 'lsp-deferred)
              (lsp-deferred))

            ;; gofmt is part of go-mode; buffer-local hook
            (when (fboundp 'gofmt-before-save)
              (add-hook 'before-save-hook #'gofmt-before-save nil t))

            (setq-local tab-width 4)
            (setq-local standard-indent 4)
            (setq-local indent-tabs-mode nil)))

;;;; Rust (optional binaries)

(use-package rust-mode
    :ensure t
    :mode ("\\.rs\\'")
    :hook
    (rust-mode . (lambda ()
                   ;; Enable rustfmt-on-save only if rustfmt exists
                   (when (executable-find "rustfmt")
                     (setq-local rust-format-on-save t)))))

(use-package cargo
    :ensure t
    :hook
    ;; Only enable cargo-minor-mode if cargo exists
    (rust-mode . (lambda ()
                   (when (executable-find "cargo")
                     (cargo-minor-mode 1)))))

(use-package eglot
    :ensure nil ;; built-in on Emacs 30
    :hook
    ;; Only enable LSP if rust-analyzer exists
    (rust-mode . (lambda ()
                   (when (executable-find "rust-analyzer")
                     (eglot-ensure)))))

(with-eval-after-load 'eglot
  (setq eglot-send-changes-idle-time 1.0)
  (add-to-list
   'eglot-workspace-configuration
   '(:rust-analyzer
     (:procMacro (:enable :json-false)
      :cargo (:allFeatures :json-false
              :features []
              :allTargets :json-false)
      :checkOnSave (:enable t
                    :command "check"
                    :allTargets :json-false)
      :inlayHints (:enable :json-false)
      :diagnostics (:experimental (:enable :json-false))
      :files (:excludeDirs ["target" "**/target" ".git" "node_modules"])))))

;;;; Magit

(use-package magit
    :ensure t
    :bind
    (("C-x g" . magit-status)
     ("C-x M-g" . magit-dispatch)))

;;;; custom LLM agent buffer

(use-package eat :ensure t)

(defcustom llm-agent-command '("claude")
  "LLM agent command to run."
  :type '(repeat string))

(defun llm--agent-buffer-name ()
  (let* ((project (project-current t))
         (root (project-root project))
         (name (file-name-nondirectory (directory-file-name root))))
    (format "*llm:%s*" name)))

(defun llm--agent-buffer ()
  (let ((buf (get-buffer (llm--agent-buffer-name))))
    (unless buf
      (user-error "No LLM buffer for this project; run `llm-eat` first"))
    buf))

(defun llm-eat ()
  (interactive)
  (let* ((project (project-current t))
         (root (project-root project))
         (default-directory root)
         (buf-name (llm--agent-buffer-name)))
    (if-let ((buf (get-buffer buf-name)))
        (pop-to-buffer buf)
      (let ((buf (get-buffer-create buf-name))
            (cmd llm-agent-command))
        (unless (and (listp cmd) (car cmd))
          (user-error "llm-agent-command must be a non-empty list"))
        (with-current-buffer buf
          (eat-mode)
          (eat-exec buf (car cmd) (car cmd) nil (cdr cmd)))
        (pop-to-buffer buf)))))

(defun llm-use-claude ()
  (interactive)
  (setq llm-agent-command '("claude"))
  (message "LLM agent set to Claude"))

(defun llm-use-codex ()
  (interactive)
  (setq llm-agent-command '("codex"))
  (message "LLM agent set to Codex"))

(defun llm-send-region (start end)
  (interactive "r")
  (unless (use-region-p)
    (user-error "No region selected"))
  (unless (buffer-file-name)
    (user-error "Buffer must be visiting a file for the agent to access it"))
  (let* ((file (buffer-file-name))
         (line-start (line-number-at-pos start))
         (line-end (line-number-at-pos end))
         (prompt (read-string "LLM prompt: "))
         (message (format "%s (see %s:%d-%d)"
                          prompt file line-start line-end)))
    (let ((buf (llm--agent-buffer)))
      (with-current-buffer buf
        (unless eat-terminal
          (user-error "LLM buffer has no active terminal"))
        (eat-term-send-string eat-terminal message))
      (pop-to-buffer buf))))

(defun llm-fix-flymake ()
  "Send the Flymake error at point to the agent for fixing.
Works both in source buffers and in Flymake diagnostics buffers."
  (interactive)
  (let ((diag (or (get-text-property (point) 'flymake-diagnostic)
                  (car (flymake-diagnostics (point))))))
    (unless diag
      (user-error "No Flymake diagnostic at point"))
    (let* ((diag-buffer (flymake-diagnostic-buffer diag))
           (file (and (buffer-live-p diag-buffer)
                      (buffer-file-name diag-buffer))))
      (unless file
        (user-error "Diagnostic's buffer must be live and visiting a file"))
      (let* ((text (flymake-diagnostic-text diag))
             (line (with-current-buffer diag-buffer
                     (line-number-at-pos (flymake-diagnostic-beg diag))))
             (message (format "Fix this error: %s (see %s:%d)" text file line)))
        (let ((buf (llm--agent-buffer)))
          (with-current-buffer buf
            (unless eat-terminal
              (user-error "LLM buffer has no active terminal"))
            (eat-term-send-string eat-terminal message))
          (pop-to-buffer buf))))))

(defalias 'claude-eat #'llm-eat)
(defalias 'claude-send-region #'llm-send-region)
(defalias 'claude-fix-flymake #'llm-fix-flymake)

(with-eval-after-load 'project
  (define-key project-prefix-map (kbd "l") #'llm-eat)
  (define-key project-prefix-map (kbd "q") #'llm-send-region)
  (define-key project-prefix-map (kbd "y") #'llm-fix-flymake))
